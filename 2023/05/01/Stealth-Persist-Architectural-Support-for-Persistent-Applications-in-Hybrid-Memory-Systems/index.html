<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Stealth-Persist: Architectural Support for Persistent Applications in Hybrid Memory Systems, Yi&#39;s Blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>Stealth-Persist: Architectural Support for Persistent Applications in Hybrid Memory Systems | Yi&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <link type='text/css' rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" media='all'/>

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Yi&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-link" style="zoom: 0.6;"></i>
      
      <span>Links</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Yi&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-link"></i>
			
			Links
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Yitrus" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Yitrus" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('the password')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/d916d5cd134a4909a11c4901a00fe76b.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <!-- <h1 class="description center-align post-title">Stealth-Persist: Architectural Support for Persistent Applications in Hybrid Memory Systems</h1> -->
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Hybrid-Memory-Systems/">
                                <span class="chip bg-color">Hybrid Memory Systems</span>
                            </a>
                        
                            <a href="/tags/A/">
                                <span class="chip bg-color">A</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Paper/" class="post-category">
                                Paper
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-05-01
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    57 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-论文信息"><a href="#1-论文信息" class="headerlink" title="1. 论文信息"></a>1. 论文信息</h2><div class="note primary">

<ul>
<li>文章来自HPCA, 2021</li>
<li>Stealth-Persist: Architectural Support for Persistent Applications in Hybrid Memory Systems</li></ul></div> 

<h3 id="所有作者及单位"><a href="#所有作者及单位" class="headerlink" title="所有作者及单位"></a>所有作者及单位</h3><ul>
<li>A, Mazen Alwadi1, Vamsee Reddy Kommareddy1, Clayton Hughes2, Simon David Hammond2, Amro Awad3<br>University of Central Florida1, Sandia National Laboratories2, North Carolina State University3</li>
</ul>
<h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h2><p>它们存在着高写延迟和有限的写持久性。研究人员提出了结合DRAM和NVM的混合存储系统，利用DRAM的低延迟来掩盖NVM的一些缺点——通过在DRAM中缓存常驻NVM数据来提高系统性能。对于大容量的NVM快速和持久的缓存能力是有限的。利用DRAM作为NVM的一个快速持久的缓存，受到能源支持的限制。</p>
<h2 id="3-解决了什么问题"><a href="#3-解决了什么问题" class="headerlink" title="3. 解决了什么问题"></a>3. 解决了什么问题</h2><p>越来越多的应用程序将利用NVMs的持久性功能。因此，提高这类应用的性能，同时保证数据的持久性是一个关键的设计点。允许NVM的非常快速的持久性缓存，但不需要任何额外的能量支持能力来刷新DRAM缓存内容到NVM</p>
<h2 id="4-其他学者解决这个问题的思路和缺陷"><a href="#4-其他学者解决这个问题的思路和缺陷" class="headerlink" title="4. 其他学者解决这个问题的思路和缺陷"></a>4. 其他学者解决这个问题的思路和缺陷</h2><p>现有的持久性存储器技术要么提供小容量但快速和基于电池支持的DRAM持久性区域，要么提供高容量的NVM (不需要电池支持)但缓慢的持久性区域。前者需要系统的支持，需要笨重的物品，并且会根据超级电容或电池的大小限制持久性DRAM的大小。此外，它需要改变某些DIMM来支持备份模式。同时，由于持久性对象的缓慢读取访问，后者会产生明显的性能下降。期待电池备份、有限的DRAM尺寸以及限制集成在系统中的DRAM模块的选择。</p>
<h2 id="5-围绕该问题作者如何构建解决思路"><a href="#5-围绕该问题作者如何构建解决思路" class="headerlink" title="5. 围绕该问题作者如何构建解决思路"></a>5. 围绕该问题作者如何构建解决思路</h2><p>实现NVM的快速持久的DRAM缓存，我们利用选择性的NVM镜像对缓存在DRAM中的持久页面进行了新的内存控制器。</p>
<p>在DRAM中缓存时将持久区域的更新镜像到NVM。 Stealth-Persist的镜像操作发生在内存控制器上，不需要对应用程序或持久性编程库做任何改变。最后，为了支持对持久性页面的高性能访问，我们的方案从DRAM中提供对持久性对象的读取请求，如果在那里有缓存</p>
<h2 id="6-从结果看，作者如何有力证明他解决了问题"><a href="#6-从结果看，作者如何有力证明他解决了问题" class="headerlink" title="6. 从结果看，作者如何有力证明他解决了问题"></a>6. 从结果看，作者如何有力证明他解决了问题</h2><h2 id="7-缺陷和改进思路"><a href="#7-缺陷和改进思路" class="headerlink" title="7. 缺陷和改进思路"></a>7. 缺陷和改进思路</h2><p>写次数不变，对于写耐久性的破坏</p>
<h2 id="8-创新点"><a href="#8-创新点" class="headerlink" title="8. 创新点"></a>8. 创新点</h2><p>虽然之前所有关于持久化应用的工作都探讨了对持久化对象的写的优化，但这是第一个探讨对持久化对象的读操作进行优化的工作。仅仅依靠对处理器芯片的微小改动来支持DRAM中持久性数据对象的缓存是非常重要的。Stealth-Persist的镜像操作发生在内存控制器上，不需要对应用程序或持久性编程库做任何改变</p>
<blockquote>
<p>crash-consistent applications 崩溃一致性程序;crash宕机，或主机、程序停止工作等情况。</p>
</blockquote>
<p><code>这篇翻译的不好，还有很多问题，会持续修改</code></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>非易失性存储器（NVM）具有传统外存系统（storage systems）持久性和传统内存系统（memory systems）字节可寻址的特点。然而，它们存在着<strong>高写延迟和有限的写持久性</strong>。研究人员提出了结合DRAM和NVM的混合存储系统，利用DRAM的低延迟来掩盖NVM的一些缺点——通过在DRAM中缓存常驻NVM数据来提高系统性能。然而，这可能会使缓存页面的持久性失效，从而导致在性能和可靠性方面的权衡问题。在本文中，我们提出了Stealth-Persist，这是一个新的架构支持功能，允许需要持久性的应用程序在DRAM中运行，同时保持NVM提供的持久性功能。Stealth-Persist创造了一个持久性内存的假象，供应用程序使用，同时利用DRAM进行性能优化。我们的实验结果表明，Stealth-Persist将持久性应用的性能提高了42.02%。</p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p><strong>新兴的非易失性存储器（NVMs）正逐渐成熟，达到了接近大规模生产阶段和广泛采用的水平[11],[15],[16],[59],[65]<strong>。 例如，最近，英特尔发布了OptaneDC产品，它是一种使用3DXPoint技术的内存模块[21]。这些NVM-based内存模块以超低的空闲功率运行，但仍然具有非常高的密度。例如，每一个Optane DC模块可以有512GB的容量[3]。因此，在需要高内存容量但可能受到电源限制的服务器中，它们是一个非常引人注目的补充。虽然DRAM模块必须频繁地进行刷新操作，它占了很大比例的电力消耗[38]，但NVM并不这样做。传统上，</strong>NVM在断电或关机后仍能保留数据，这对崩溃一致性应用程序非常有用</strong>[9],[17]，并能承载快速访问文件[52]。然而，新兴的NVM的读写延迟比DRAM的延迟要低很多。例如，在英特尔的OptaneDC上，读取延迟为300ns，而DRAM的读取延迟接近70ns[46]4.3倍慢的读取访问。虽然NVM的<strong>写延迟可以通过外部缓冲或利用电池支持的内部写缓冲器来隐藏</strong>(例如， 英特尔的Optane DC)写入延迟队列)，NVM的设备写入延迟可以比DRAM的延迟慢十倍[13],[33]。</p>
<p>新兴NVM持久特征的未来对于许多<strong>数据恢复和崩溃一致性至关重要的应用</strong>是有吸引力的[40]。此外，新兴的NVM允许直接访问和更新持久性文件，而不会产生昂贵的缺页[52]。例如，数据库的在NVM上可以有几百个千兆字节，并且可以直接在应用程序中进行读写操作，类似于DRAM[52],[59]。此外，英特尔的持久性内存开发工具包( PMDK)允许开发应用程序，<strong>利用NVM的持久性对关键数据结构进行持久更新[9]。理想情况下，在崩溃之后，持久性应用程序应该能够通过从NVM读取数据结构来恢复</strong>[14]。然而，NVM的大的读/写延迟会大大减慢对持久性数据的访问。在其他方面，每个应用程序需要在使用低(相对于DRAM)的NVM和使用DRAM之间做出选择，前者可以实现崩溃一致性 ，后者则会失去内存子系统中的持久性能力。随着新兴的NVMs的不断采用，以及持久性编程库( 如PMDK)的日益普及，我们预计越来越多的应用程序将利用NVMs的持久性功能。因此，提高这类应用的性能，同时保证数据的持久性是一个关键的设计点。</p>
<p>新兴的NVM可以作为存储设备( 例如，在SSD内)如英特尔的Optane硬盘[1] ，或作为部分或系统的内存层次。为了将NVM集成到内存层次中，有很多标准和选项[2],[3],[6]。 最值得注意的是，英特尔的类似DIMM的NVM模块( 称为OptaneDC[3])可以作为主存储器或作为主存储器的一部分与其他存储器选项(如DRAM和HBM)一起集成。在作为主内存的一部分使用时，它可以作为一个单独的物理内存添加区，扩大DRAM的物理地址范围，<strong>或者将DRAM作为OptaneDC的物理范围的硬件管理缓存使用[3]。前者被称为App Direct 模式，这类似于将不同的内存区域暴露于非统一存储器体系结构（NUMA）中的系统</strong>。我们把后者称为内存模式。<strong>内存模式放弃了持久性特性</strong>，因为当应用程序从内部缓存刷新其更新时，可以在易失性DRAM中更新内存块。然而，<strong>由于DRAM缓存大量的NVM页面，可以大大改善访问延迟</strong>，特别是对于频繁使用的页面。另一方面，<strong>AD模式确保了映射到NVM地址范围的页面的持久性，但由于它依赖于容量有限的内部处理器缓存(而不是外部DRAM)，因此会产生巨大的成本</strong>。   因此，目前Optane内存模式的集成操作，忽略了持久性应用对持久和高性能的需求。</p>
<p>JEDEC还为含有NVM的内存模块提供了几种标准。特别的，JEDEC为含有NVM的DIMM (称为NVDIMM)定义了三种不同的标准，即NVDIMM-N、NVDIMM-P和NVDIMM-F[5], [6]。这三种不同的选择提供了不同的暴露容量、持久性保证和管理复杂性的折中。特别的，NVDIMM-N只将DRAM暴露给软件，并在崩溃期间利用超级电容器为DIMM供电，提供将DRAM数据复制到NVM的能力( 目前是 flash-based基于闪存的)。因此，NVDIMM-N具有类似于DRAM的<strong>暴露延迟</strong>，但将内存容量限制在DRAM大小。NVDIMM-F將NVM (目前是基于闪存)暴露给软件，并作为一个块设备直接访问。平均而言，NVDIMM-P对不同的NVM技术有更广泛的定义，并允许内部DRAM缓存与NVDIMM-P的几个持久性选项，如<strong>深冲命令</strong>，因为NVDIMM-P没有能量支持。NVDIMM-P的一个主要优是它利用了<strong>一个交易协议，允许它使用非确定性的时间</strong>，与NVDIMM-N和NVDIMM-F相比，它依赖于确定性的时间。显然，在这三种选择中，NVDIMM-P是最适合新兴的NVM (不是为闪存定制的)和高容量系统。此外，由于DIMM上有高效的能源支持，内部DRAM可以被认为是NVDIMM模块内的NVM的一个高速缓存。NVDIMM-P没有能量支持（energy-backing），除了DRAM缓存在NVDIMM-P中而不是像内存模式下的独立模块，其他与内存模式下的Intel’s Optane DC类似。</p>
<p>虽然NVDIMM-P作为一个概念很有趣，但由于以下原因，对于大容量的NVM快速和持久的缓存能力是有限的。首先，如果需要几十或几百GB的DRAM来有效地缓存大型NVM，那么就需要笨重和潜在的昂贵的电池来提供能量支持。此外，由于能源支持只支持内部DRAM，客户被限制在相同的供应商和NVDIMM-P中可用的DRAM缓存的特定大小容量。另外，具有独立的NVM和DRAM模块的杠杆老化内存模式解决了NVDIMM-P的灵活性限制，但需要昂贵和不环保的( 和笨重的)电池支持[43]。换句话说，利用DRAM作为NVM的一个快速持久的缓存，受到能源支持(或独立能源)能力的限制，然而这种能力需要在需要大型DRAM模块时得到更多的提升。因此，我们在<strong>本文中的目标是允许NVM的非常快速的持久性缓存，但不需要任何额外的能量支持能力来刷新（flush）DRAM缓存内容到NVM</strong>。因此,<strong>我们能够在有NVM的系统中集成首选的DRAM模块，同时也能在DRAM中实现持久性数据的缓存，而不牺牲持久性或需要额外的电池支持能力。</strong></p>
<p>为了实现NVM的快速持久的DRAM缓存，我们利用<strong>选择性的NVM镜像</strong>对缓存在DRAM中的持久页面进行了新的内存控制器。<strong>我们的方法支持两种内存模式和AD模式</strong>，并能确保对缓存在DRAM中的持久页面的更新的持久性。此外，我们的内存控制器通过放松对DRAM缓存页更新的镜像， <strong>将写入NVM的次数降到最低</strong>，如果他们在NVM中的源页是在NVM的逻辑非持久性部分(即，用于支持不需要持久化的页面)。类似于当前处理器中的内存模式支持我们的内存控制器透明地在NVM和DRAM之间迁移页面。然而，我们通过从NVM中的原始地址推断出其语义来确保DRAM缓存页的持久性。如果页面被缓存在DRAM中，我们的方案只会产生额外的写入，此外，NVM的写入也会发生。然而，未来的读取将从DRAM中进行，这使得快速和持久的NVM页面的缓存成为可能。此外，通过允许持久性页面位于DRAM中，我们的方案利用额外的银行级别的并行性来访问持久性页面，而不是强迫所有的访问到NVM。我们的方案在精神上类似于内部处理器缓存中通常使用的write-through方案，但是由于写的性质和DRAM如何暴露给系统(内存模式或应用直接模式)，涉及到新的优化和设计考虑。虽<strong>然之前所有关于持久化应用的工作都探讨了对持久化对象的写的优化，但这是第一个探讨对持久化对象的读操作进行优化的工作</strong>。</p>
<p>为了评估我们的设计，我们使用了Whisper基准[41]中的持久性应用程序。为了研究我们方法的可靠性，我们还开发了6个内存密集型基准，类似于Janus[37]以前的工作。 一个开放源码的架构模拟器，结构模拟工具包(SST) [50]用来被模仿我们的方法。平均来说，与只使用NVM持久性应用相比，我们观察到<strong>42.02%性能的提高和88.28%NVM的读取减少</strong>。请注意，对持久性数据只使用NVM是唯一允许在没有任何备用电池的情况下进行数据持久化的选择，因此被作为我们的基线使用。<br>综上所述，我们的工作的贡献如下。</p>
<ul>
<li>我们提出了Stealth-Persist，这是一种新的硬件支持， 通过在DRAM中实现对热持久页的缓存来提高持久性应用的性能，同时确保数据的持久性，不需要外部电源支持且软件透明。</li>
<li>我们讨论了将Stealth-Persist与混合DRAM-NVM主存储器系统的实现垂直和水平的相结合。</li>
<li>我们讨论了Stealth-Persist的设计方案，在方案性能和镜像页面的数量之间进行了权衡。</li>
<li>我们广泛地分析了Stealth-Persist在不同的区域大小、不同的替换策略和不同的镜像阈值下的开销。</li>
</ul>
<h1 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h1><p>在本节中，我们将介绍与我们的工作相关的主题，以帮助读者了解我们的工作，然后是工作动机。</p>
<h2 id="A-新兴的非易失性存储器"><a href="#A-新兴的非易失性存储器" class="headerlink" title="A.新兴的非易失性存储器"></a>A.新兴的非易失性存储器</h2><p>新兴的NVM，如3DXPoint和英特尔的OptaneDC，具有更高的密度、字节寻址能力、更低的每比特成本、比DRAM更低的空闲功耗和非易失性，但具有<strong>更高的访问延迟和有限的写入耐久性</strong>[15],[32],[33],[35]。例如，NVM-based DIMM可以被用来存储文件和内存页，它可以使用常规的加载/存储操作来访问。为了实现这种类型的访问，最近的操作系统(OS)开始支持通过DAX文件系统[52]将内存配置为持久性或非持久性。在DAX文件系统中，一个文件可以直接被内存映射和使用常规的加载/存储操作访问，而不需要将其内容复制到页面缓存中[15]。然而，<strong>NVM的访问延迟比DRAM的访问延迟慢3-4倍</strong>。因此，研究者主张建立同时具有NVM和DRAM部分的内存系统[48]，[62]。</p>
<h2 id="B-混合主存储器-HMM"><a href="#B-混合主存储器-HMM" class="headerlink" title="B.混合主存储器(HMM)"></a>B.混合主存储器(HMM)</h2><p>混合主存储器( HMM)系统由于其密度和超低的空闲功率，预计将有很大的NVM部分，而由于其快速的读/写操作DRAM部分將很小。HMM可以以两种不同的方式部署，水平或垂直。在垂直方向上，NVM作为一个新的内存层被连接起来，DRAM被用来缓存NVM的数据[3],[6]。这种方案允许更快地访问大型内存池，并且需要特殊的硬件将数据从NVM迁移到DRAM，例如，在英特尔的OptaneDC内存模式下，英特尔的Xeon可扩展处理器的内存控制器对缓存线进行缓存。然而，因为DRAM的波动性，这样的方案并不能提供持久性。在第二种方法中，HMM系统的水平实现将NVM和DRAM暴露在物理地址空间中，就像在NVDTMM-P和OptaneDC的AD模式中那样，如果需要的话依靠OS来处理数据访问和页面迁移[27],[47],[48],[58]。在这两种情况下， 需要有混合内存管理方案，管理不同的持久性和性能要求。</p>
<p>文献中提出了基于内存层次的不同混合内存管理方案。诸如HetroOs[27]、RTHMS[44]和Nimble[58]提出了软件解决方案，以检测哪些页面需要迁移到最快的内存(例如，DRAM)。当DRAM和NVM都被内存映射并暴露给操作系统时，这些方案适用于<strong>混合内存系统的水平实施</strong>。另一方面，混合内存系统的垂直实施将DRAM作为一个缓存。因此，DRAM没有暴露给操作系统，其中缓存页使用专用硬件处理，通常是内存控制器的扩展，如英特尔的OptaneDC内存模式[3]。像Ramos等人[48]提出的方案，根据每个页面被访问的频率，使用多队列(MQ)结构对页面进行排名，然后使用页面的排名来决定哪些页面需要迁移到DRAM中，哪些页面需要保留在NVM中。然而，跟踪所有的页面并检查MQ结构来提升和降低页面的等级会产生很高的开销，因此在每个时间段只检查队列的头部。在讨论了混合内存系统的管理方案之后，我们讨论了一些用于HMM中的页面缓存的方案。</p>
<h2 id="C-页面缓存策略"><a href="#C-页面缓存策略" class="headerlink" title="C.页面缓存策略"></a>C.页面缓存策略</h2><p>页面缓存策略是用来决定哪些页面应该被缓存在DRAM中，如果你想缓存NVM的页面。在这一节中，我们将讨论两个策略，这些策略将在我们的设计中使用。</p>
<p><strong>首次触摸策略</strong>。该策略在第一次访问时缓存页面，并根据LRU算法选择一个页面进行驱逐。<br><strong>多队列(MQ)<strong>。多队列(MQ)。MQ最初被设计用来对磁盘块进行排序，后来被Ramos等人[48]用于混合内存系统的页面放置。MQ的工作方式如下。MQ定义了M个块描述符的LRU队列。队列的编号从0到M-1， 队列M-1的块是访问量最大的块。每个描述符都包含区块的编号、一个引用计数器和一个逻辑到期时间。在第一次访问一个区块时，它的描述符被放在队列0的尾部，其过期时间被更新为<code>CurrentTime+LifeTime</code>。这</strong>两个时间都是以访问次数来衡量</strong>的，<code>LifeTime</code>代表在区块过期前对不同区块的连续访问次数。每次区块被访问时，其过期时间被重置为<code>CurrentTime +LifeTime</code>，其引用计数器被递增，其描述符被推到其当前队列的尾部。在队列i中的块的描述符被访问了一定数量后，它被提升到队列i+1，在队列M-1中达到饱和。另一方面，最近没有被访问的区块会被降级。在每次访问时，所有队列头部的描述符都被检查是否过期。如果描述符过期了，它就被放在下面队列的尾部，其生命时间被重置，其降级标志也被设置[48]。如果一个描述符连续收到两次降级，该描述符将被从MQ结构删除。为了减少升级/迁移的开销，这些操作只在每个周期结束时进行。</p>
<p>由于已经证明MQ在选择要替换的页面方面优于其他算法[48], [64], 它与我们的目标一致。因为它有助于检测出性能关键的页。因此，在我们的实验中，我们使用了Ramos等人提出的MQ设计[48]。在讨论了缓存策略之后，我们现在提到了目前可用的工业混合内存系统的实现。</p>
<h2 id="D-目前的工业HMM系统"><a href="#D-目前的工业HMM系统" class="headerlink" title="D. 目前的工业HMM系统"></a>D. 目前的工业HMM系统</h2><p>目前，市场上有不同类型的HMM系统。例如，JEDEC定义了三种不同的被称为NVDIMM的HMM标准。NVDIMM类型有不同的特点、持久性和性能特征。此外，英特尔最近透露了关于Optane DC的内存模式和AD模式的细节。<br><strong>NVDIMM-N</strong>包含一个DRAM部分，一个NVM部分，以及一个超级电容。系统在正常执行时使用DRAM，而NVM只在崩溃时使用超级电容供电用于复制DRAM数据。[6]<br><strong>NVDIMM-F</strong>模块是连接到DDR总线上的NVM，它的访问延迟相对高于DRAM。因此，可以在系统中安装一个DRAM，并用于缓存NVDIMM-F的数据，代价是数据的持久性|6]。<br><strong>NVDIMM-P</strong>仍然是一个DIMM的建议，它有内存映射的DRAM和NVM，其中软件根据数据的大小和持久性要求将数据放在NVM或NVDIMM中。<br><strong>Optane DC内存模式</strong>是英特尔持久性内存的一种操作模式。它类似于NVDIMM-P。</p>
<h2 id="E-持久性内存编程模式"><a href="#E-持久性内存编程模式" class="headerlink" title="E. 持久性内存编程模式"></a>E. 持久性内存编程模式</h2><p>由于NVM的持久性特点，访问一个NVM内存对象就像访问一个存储文件。因此。应用程序需要一种方法来重新连接到先前分配的存储器对象。因此，持久性内存区域需要名称和访问控制来进行访问。存储网络工业协会（SNIA）建议操作系统提供命名、权限和内存映射的标准文件语义。因此，一些操作系统增加了对文件系统的直接访问（DAX）支持[4]。DAX允许应用程序直接使用持久性内存而不使用系统的页缓存。图1显示了持久性内存感知文件系统的工作原理[52]。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/d916d5cd134a4909a11c4901a00fe76b.png"></p>
<p>使用持久性内存（PM）对象需要程序员考虑多个问题以确保数据的持久性和一致性。其中一个问题是原子性；什么样的支持由硬件提供，而什么是留给软件处理的[52]。英特尔的硬件确保了8字节写入的原子性，因此如果一个对象大于8字节，那么软件就有责任确保更新对象的原子性[52]。此外，<strong>确保数据的持久性需要将数据一直推送到持久性领域</strong>，因为大部分的数据更新是在易失性处理器的缓存中完成的。持久域从内存控制器中的一个小的缓冲区，即<strong>待处理队列（WPQ）开始。WPQ由异步DRAM (ADR)刷新功能支持。ADR提供的电源可以确保在断电的情况下将WPQ的内容刷新到NVM上</strong>[15], [55], [59], [65]。图2显示了具有持久性存储器的系统中的持久性域。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/444a25e88ec046da99d0953429fe4d21.png"></p>
<p><strong>为了将数据一直刷新到持久化区域。确保原子性和排序，需要遵循一组特定的指令</strong>。清单1显示了一个代码例子，它取自来自SNIA的NVM编程模型V1.2[8]。该代码显示了持久化对象<code>a</code>和<code>a_end</code>。为了确保这些持久化对象的更新的一致性、原子性和顺序性，每次更新这些持久化对象之一时都会调用<code>msync</code>操作。请注意，第7行的更新没有使用<code>msync</code>操作，因为它不是在更新一个持久化对象。<code>msync</code>操作是用来<strong>强制更新一个内存范围到持久化领域的</strong>。此外，它创建了一个屏障，以保证在继续进行之前执行先前的存储，<code>fsync</code>操作做的是对文件具有相同的功能[52]。</p>
<h2 id="F-动机"><a href="#F-动机" class="headerlink" title="F.动机"></a>F.动机</h2><p><strong>在主存储器中拥有一个持久性的部分可以使应用具有不同的持久性要求。然而，为了确保数据的持久性，应用程序的持久性数据应该被放置在内存的NVM部分，由于NVM的访问延迟较慢，这阻碍了这些应用程序的性能</strong>。另一方面，将应用程序的数据放在DRAM上，会导致更好的性能，但不能满足这些应用程序的数据持久性要求。为了确保应用程序的数据持久性，持久性应用程序应该遵循第二节E中提到的编程模型。如前所述，<strong>现有的持久性存储器技术要么提供小容量但快速和基于电池支持的DRAM持久性区域，要么提供高容量的NVM (不需要电池支持)但缓慢的持久性区域</strong>。前者需要系统的支持，需要笨重的物品，并且会根据超级电容或电池的大小限制持久性DRAM的大小。此外，它需要改变某些DIMM来支持备份模式。同时，由于持久性对象的缓慢读取访问，后者会产生明显的性能下降。虽然持久性应用的数据大小不太可能适合易失性缓存，但在大得多的DRAM中缓存这种持久性数据可以为持久性对象提供明显的读取速度提升。同时，期待电池备份、有限的DRAM尺寸以及限制集成在系统中的DRAM模块的选择( 如供应商)， <strong>是现有解决方案的主要缺点</strong>。因此，仅仅依靠对处理器芯片的微小改动来支持DRAM中持久性数据对象的缓存是非常重要的。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/b9c998558da04df3b8e44015a419ded8.png"></p>
<p>表一是现有技术之间的比较。从表一中，我们可以观察到，在支持高技术方面的差距。性能持久性内存，以及大容量持久性内存，因此<strong>Stealth-Persist旨在弥补这一差距</strong>。图3显示了在OptaneDC AD模式(所有持久性数据都在NVM中)上运行的持久性应用的性能开销，与在不提供数据持久性的DRAM系统上运行的性能开销相比。从图3中，我们可以看到，在OptaneDC的AD模式上运行的应用平均会产生2.04倍的速度下降。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/003104b458bd4b08824b99b3b496a649.png"></p>
<h1 id="三、设计"><a href="#三、设计" class="headerlink" title="三、设计"></a>三、设计</h1><p>在本节中，我们根据可能的设计方案及其权衡来讨论Stealth-Persist的设计。首先，我们开始讨论设计要求，以及潜在的设计方案。</p>
<h2 id="A-设计要求"><a href="#A-设计要求" class="headerlink" title="A.设计要求"></a>A.设计要求</h2><p>我们的设计应该满足必要的要求，以允许广泛采用和高性能，同时保留持久性对象的语义。总的来说，这些要求如下。</p>
<ul>
<li>灵活性:我们的设计应允许将任何DRAM模块，无论其容量如何，都集成到配备有NVM的系统中，而不需要任何特殊的电池备份或特定的DIMM修改。</li>
<li>持久性:任何被认为是持久的内存页或对象(即，可从崩溃中恢复)应该是可恢复的，而不需要任何额外的电池备份支持，无论该页位于何处(NVM或DRAM)。</li>
<li>高性能:对持久性页面和对象的访问应该和对DRAM的访问一样快。</li>
<li>透明度:利用持久性内存进行崩溃恢复的应用程序不应该需要明确地管理当前驻留在DRAM中的对象的缓存和持久化。</li>
</ul>
<p>为了把这些要求放在持久性应用的背景下，我们可以想象一个访问几十GB持久性对象的持久性应用。 理想情况下，除了NVM模块外，系统还应该能够集成DRAM模块。系统的所有者应该可以灵活地选择什么样的容量和供应商来选择这样的DRAM和NVM模块，这就提供了灵活性。然而，对持久性对象的更新应该是持久的并且在崩溃时持久存在，无论它们存在于何处(DRAM或NVM)。虽然通过持久性模型和框架，即<code>clflushes</code>和内存栅栏使易失性缓存中的对象的更新变得持久，但如果持久性对象被缓存在片外DRAM中，目前还没有支持保证它们的持久<br>性，这给我们带来了持久性要求。最后，<strong>应用程序最好能将其持久性对象缓存在DRAM中</strong>，以尽量减少获取不适合在易失性处理器缓存中的持久性对象的成本。因为<strong>这些对象通常只有几兆字节的易失性处理器缓存</strong>。获取片外持久性对象的延迟比慢速NVM的延迟短（300ns的读取延迟与70ns的DRAM相比），这一要求使我们看到了设计要求的第三个要素，即高性能。因此,持久性应用应该能够将不适合内部易失性缓存的持久性对象缓存在快速的片外DRAM中，同时保留其持久性能力。最后，所有用于缓存和持久化持久性对象页面的操作都应该透明地发生在软件上，而不需要将这些细节暴露给应用程序，这就给我们带来了最后一个要求，即透明度。</p>
<h2 id="B-设计选项"><a href="#B-设计选项" class="headerlink" title="B.设计选项"></a>B.设计选项</h2><p>现在我们将讨论有可能满足我们要求的设计方案。</p>
<p>一种选择是支持新的指令，<strong>在缓存线被刷新之前不提交——不仅从易失性缓存，而且从片外DRAM到NVM</strong>。这种设计方案可以通过在内存控制器的支持下向指令集架构(ISA)引入新的指令来实现，或者通过修改当前指令的实现，<strong>使其从内部易失性高速缓存( 例如，clflush)以及从DRAM到NVM中刷新缓存线。假设DRAM是通过内存控制器作为NVM数据的硬件管理缓存来运行的，这样的指令就需要内存控制器首先检查要保存的缓存线是否在DRAM中，读取它，然后将它刷新到NVM中</strong>。这种方法的主要问题是。(1)它需要改变ISA、持久性编程库和处理器内核来支持这种新的指令。此外，(2)持久化数据的延迟将大大增加，特别是当刷新的块在DRAM中被标记为脏块时。请注意，即使DRAM缓存的是页而不是缓存行，它仍然需要类似的支持，但需要新的指令在页的粒度上操作，而不是<code>clflush</code>。</p>
<p>另一个选择是利用小型固定尺寸的备份能力(例如，超电容)， 为刷新DRAM的特定部分提供动力。例如，无论模块的总大小如何，都要有足够的电力来刷新8GB的DRAM。内存控制器或系统的软件可以潜在地迁移或在地址空间的这个子区域放置持久的页面，标记为持久的。当电源故障发生时，内存控制器( 或外部系统电路)有足够的电力来刷新DRAM的那一部分。虽然这样的解决方案在精神上类似于NVDIMM-N，它提供了选择任何DRAM模块和容量的灵活性。然而，具有持久性支持的部分的大小被限制在系统的备份能力范围内。另一方面，这样的解决方案需要外部系统的支持，并将DRAM的持久性部分的大小限制在电源备份能力上。同样，这样的备份能力通常成本很高， 需要高面积(笨重)， 而且可能对环境不友好。</p>
<p>虽然第一种方案提供了高性能、持久性和灵活性，但它缺乏透明度。同时，第二种方案具有部分灵活性(需要系统支持和可能的ISA变化)， 部分的高性能(只有一小部分DRAM可以作为持久性内存使用)， 透明度和持久性。因此，我们的设计应该提供完全的透明度、高性能、持久性和灵活性，而不需要任何额外的系统支持或超出现代系统所提供的备份能力。</p>
<h2 id="C-Stealth-Persist"><a href="#C-Stealth-Persist" class="headerlink" title="C.Stealth-Persist"></a>C.Stealth-Persist</h2><p>在满足上述设计要求的同时，我们的设计还应该与混合内存系统的不同集成方式兼容。特别是垂直内存模式(如Optane DC的内存模式)和水平内存模式(如OptaneDC的AD模式)在深入探讨不同集成模式下Stealth-Persist支持的细节之前，我们将讨论Stealth-Persist如何满足设计要求。</p>
<p>为了满足灵活性的要求，Stealth-Persist的实现是为了支持在DRAM中缓存时将持久区域的更新镜像到NVM。因此，它不需要系统的任何支持，并且可以在任何DRAM大小下工作。通过镜像缓存在DRAM中的持久性页面的更新，持久性的要求得到了满足。为了使我们的解决方案对软件透明， Stealth-Persist的镜像操作发生在内存控制器上，不需要对应用程序或持久性编程库做任何改变。最后，为了支持对持久性页面的高性能访问，我们的方案从DRAM中提供对持久性对象的读取请求，如果在那里有缓存。图4描述了Stealth-Persist中的读写操作，在高层次上。</p>
<p>如图4所示，内存控制器集线器MCH)处理对持久性页面的写入的镜像，如果在而直接从DRAM上提供读取请求。通过这样做，Stealth-Persist确保了对NVM的写入的持久性，同时允许对这种持久性对象进行快速的读取操作。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/69796fb223084662b46606e733932280.png"></p>
<p>虽然在高层次上，这种设计<strong>看起来类似于内部处理器缓存中通常使用的写通方案</strong>，但在考虑到混合内存系统的背景时，会出现许多挑战和潜在的分歧。第一个挑战是<strong>如何决定一个页面是否应该被镜像</strong>。第二个挑战是<strong>如何快速识别一个页面是否被缓存在DRAM中，它被缓存在哪里</strong>?以及<strong>在运行期间如何保证两个副本都是一致的</strong>。第三，<strong>由于不是所有NVM中的页面都需要被持久化，对存储在NVM中的页面的更新需要有选择地进行镜像</strong>。最后，Stealth-Persist需要进行调整，以适应无数种整合混合内存系统的方式。本节的以下部分将讨论这些挑战以及我们如何克服它们。</p>
<p>1)页面镜像。无论使用何种HMM管理方案，水平(例如应用程序直接模式)或垂直(内存模式)， Stealth-Persist都需要将部分(或整个) DRAM作为持久性页面的镜像区域。<strong>在垂直内存设置中， 整个DRAM将被用作NVM的缓存，因此，任何缓存在DRAM中的页面也可能被镜像到NVM中</strong>。同时，<strong>在水平设置中，由于DRAM和NVM的物理范围明确地暴露在系统中，我们让内存控制器保留一部分DRAM，仅作为镜像区域使用。DRAM的其余部分将直接暴露给系统</strong>，就像在AD模式中一样。位于NVM中的任何持久性页面都可以被缓存在DRAM的镜像区域中， 而不考虑设置，也就是这种区域的大小。<strong>在每个以NVM地址为目标的内存访问中，我们需要透明地检查该页是否当前驻留在DRAM中。读取和写入操作都需要这种检查;如果访问的页面被缓存在DRAM中，那么读取操作可以直接从DRAM中进行，而写入操作则需要更新NVM中的副本，以保证镜像页面副本之间的一致性并确保持久性。当一个页面不在DRAM中时我们需要从NVM中读取它(或写人它)。由于镜像区域可以被认为是NVM中持久性页面的缓冲区/缓存，我们需要为DRAM中的所述缓存/缓冲区定义插入和驱逐策略</strong>。</p>
<p>为了简单起见，我们使用了一个类似于垂直内存管理方案中使用的页面插入策略。通过这样做，如果使用内存模式，除了在DRAM中缓存持久性页面时向NVM进行额外的写入外，不需要对管理策略进行任何改变。同时，对于AD模式，在DRAM中定义的镜像区域将被管理，类似于内存模式中的DRAM缓存，此外还有对NVM的镜像写入。考虑到这一点，我们<strong>使用了两个简单的策略来放置DRAM缓冲区中的页面</strong>: ( 1)首次触摸策略(FTP)和(2) 多队列(MQ)策略，正如之前的工作中所提出的[48]。</p>
<p>2)DRAM镜像区域查询。为了确保Stealth-Persist可以快速<strong>检查一个页面是否在DRAM中(镜面区域的地址）， Stealth-Persist使用一个硬件管理表来跟踪镜面区域的页面</strong>。镜像的映射表包含了镜像的缓存页地址的转换，如图5所示。映射表的每个条目都包含一个组ID,它是用NVM中的镜像页地址与镜像区域的页数的模数函数来计算的。此外，每个条目包含六对转换，将36位NVM的页面地址映射到36位镜像DRAM的页面地址。此外，我们为每个翻译使用3位(共18位)作为替换策略的LRU位，这使得翻译总共有450位，其余512位用于组ID (32位) 和填充。因此，一个页面可以通过时钟替换策略或条目内的LRU驱逐从镜像区域中移除。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/8130fea0f2ba4f3bbadb1dff9316d3c4.png"></p>
<p>请注意，镜像的映射的存储要求是在镜像区域中， 每6页的映射表是64字节。因此，我们<strong>在内存控制器中使用一个小的缓存来缓存镜像的映射表项，同时在DRAM中保持该表</strong>。每当收到对持久化区域的内存请求时，就会计算被请求页的组ID，并检查镜像的映射表缓存是否有被请求的组ID,这可能导致三个不同的情况。(1）该条目被缓存，页面被缓存，请求从相关的DRAM页面提供。(2)条目缓存，页面没缓存，条目没有镜像，请求要去NVM。(3)条目没有被缓存，必须检查DRAM中的映射表以获得条目和它的镜像页。由于映射表缓存缺失可能会导致从DRAM中提供请求，并进行两次访问，或者在检查DRAM后从NVM中提供请求，所以我们将请求发送到DRAM中，如果条目在表中，NVM再从DRAM中提供请求，如果不在表中，则从NVM中提供。</p>
<p>3)镜像页的连贯性更新。在Stealth-Persist中，镜像区域页和NVM页之间应该保持一致性 。由于持久性页面被认为是可恢复的，对持久性页面的写入应该是持久的。因此，对镜像区域的写入应该被推送到两个内存。Stealth-Persist将对镜像区域页面的写请求推送到DRAM的易失性写缓冲区和NVM的持久性WPQ。请注意，<strong>一个写请求只有在它被放入WPQ后才会退役，这保证了写的持久性。另一方面，属于非持久性区域的镜像页不需要数据一致性 ，也不需要可恢复性，这就是为什么Stealth-Persist实现了选择性镜像</strong>。Stealth-Persist对一致性没有任何影响。如果DRAM和NVM模块在同一个插座（socket）上，这是英特尔的DCPMM所支持的配置，NVM和DRAM拷贝之间的一致性由MC通过镜像来管理，而与内部处理器缓存的一致性是在传统系统中处理。然而，如果我们偏离了目前的标准，即NVM和DRAM在同一个插座上，即各自在不同的插座上，那么我们可以指定靠近NVM的内存控制器作为主控，因此它将负责处理镜像、重映射等，并相应地将镜像表缓存中的任何请求转发给拥有DRAM模块的插座的内存控制器。</p>
<p>4)选择性镜像。Stealth-persist实现了选择性镜像技术，以减少对NVM的写入次数,这可以通过将<strong>指向非持久性区域的写入只提交给其DRAM镜像版本来实现</strong>。Stealth-Persist在垂直HMM实现中实现了选择性镜像，就像在Optane DC的内存模式中一样，在水平HMM实现中实现了OptaneDC的AD模式。在这两种情况下，StealthPersist需要持久性内存区域的地址范围，这可以在系统启动时由内核传递给Stealth-Persist，例如，Linux 命令<code>memmap= 2G!8G</code>可以用来保留一个从地址8G开始的2GB持久性区域。请注意，将非持久化区域中的页的写操作只转发到其镜像版本，会违反这些页的一致性。 然而，由于这些页面是在非持久性区域中，而且这些应用预计是不可恢复的，所以写入可以只提交给镜像页面，而如果页面被驱逐，整个页面将被写回NVM。</p>
<h2 id="D-概述"><a href="#D-概述" class="headerlink" title="D.概述"></a>D.概述</h2><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/ec2628a98966478c8c30d234e670ce39.png"></p>
<p>图6显示了整个Stealth-Persist设计。对于每个最后一级缓存(LLC)的缺失，首先内存控制器检查该请求是否是对持久性区域的请求①如果是对持久性区域的请求，镜像表缓存被查询到NVM页面的当前状态②。如在三C2节中讨论过，镜像表缓存通过查看已经缓存的镜像表条目，或者从存储在DRAM中的镜像表中获取条目，并使用LRU策略替换组ID和相应的映射表条目，来验证NVM的页面镜像状态③如果页面被镜像，读取请求被转发到DRAM，而写入请求被转发到DRAM，以更新镜像区域，以及NVM，以保持数据④。在读的情况下，持久化内存访问被转发到多队列或FTP单元CT⑤这单元决定一个页面是否应该被镜像，如果是，则镜像表缓存被触发，使用LRU策略⑥替换其中一个映射。</p>
<h2 id="E-Stealth-Persist-NVM库的比较"><a href="#E-Stealth-Persist-NVM库的比较" class="headerlink" title="E. Stealth-Persist NVM库的比较"></a>E. Stealth-Persist NVM库的比较</h2><p>一些研究提出使用NVM库来解决NVM作为主存储器时的原子性、崩溃一致性和性能问题。NVM库的重点是将写操作移出关键路径以提高性能，但没有减少读延迟。相比之下，Stealth-Persist通过减少基本的内存读取操作的延迟来提高性能，这在NVM库中仍然是需要的。一些方案专注于容错(如Pangolin[61])、性能和强一致性(如NOVA[57]) 、减少编程工作量和性能(如Pronto[39]) 。虽然这些方案通过将写入开销移出应用程序的关键路径，或者通过在DRAM中缓冲一些更新来提高系统的性能，但是如果需要持久性，对NVM的写入是不可避免的。与此相反，Stealth-persist在写到NVM时，如果它们是指向NVM中的一个持久性区域，就会传播到NVM，并将写到非持久性区域的写入缓冲在DRAM的缓存页中。此外，Stealth-Persist在与所提出的NVM库不同的层中运行，这使得Stealth-Persist与这些方案正交。事实上，Stealth-Persist可以与上述方案同时使用，以进一步提高性能。</p>
<p>在一个不同的方向，Hagmann[24]提出了一个方案维护个日志以恢复磁盘中的文件系统。Petal[34]通过创建虚拟磁盘，使客户能够访问分布式磁盘，从而改善系统的性能，提高吞吐量。为了提供可恢复性，Petal使用写前记录。Condit等人[23]提出了一个方案，使用影子分页使持久性存储器的崩溃一致性， 在这个方案中，写是原地提交或使用局部的写时拷贝。Linux文件系统的BTRFS[49]使用B树数据结构，并使用写时拷贝作为更新方案。Rosenblum和Ousterhot[51]提出了一个日志结构的文件系统，该系统以顺序的方式执行所有写入磁盘的操作，并保持索引信息以加快数据检索。Seltzer等人。[53]提出了一个日志结构的文件系统，它具有更好的写入性能，更少的恢复时间，并能实现嵌入式事务和版本管理。提出这样的方案是为了确保原子性、可恢复性，并提高性能在磁盘中。然而，在确保持久性的同时，这些方案并没有提<br>高读取操作的性能。因此，它们与Stealth- Persist是正交的。</p>
<h1 id="四、方法论"><a href="#四、方法论" class="headerlink" title="四、方法论"></a>四、方法论</h1><p>我们在结构模拟工具包( SST)模拟器中对Stealth-Perit进行建模[50]。SST是一个基于周期级事件的仿真器， 对不同的硬件组件进行模块化设计。SST在工业界和学术界被广泛使用[28],[30],[31]。我们实现了一个混合的内存控制器组件，以处理DRAM和NVM。表二显示了模拟系统的配置。模拟的系统包含4个失序的内核，每个内核在每个周期执行2条指令。核心的频率是2GHz。三个级别的缓存，L1，L2和L3(包括)被模拟为32KB，256KB和1MB。DRAM的容量为1GB，NVM的容量为4GB。（请注意，选择DRAM和NVM的大小是由于仿真速度的限制，然而，最重要的参数是镜像区域的大小( 32MB)和应用程序的平均足迹( 256MB)。， 由于持久性应用程序的所有数据将驻留在NVM中，并且可以在镜像区域中持久性地缓存，因此我们关注应用程序的足迹与镜像区域的比例(8:1的比例) ，我们在本文后面将对此进行修改。） NVM的读写延迟为150ns和500ns[14]。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/f75fb2353b384d6cb0f88987635402e5.png"></p>
<h2 id="A-负载工作"><a href="#A-负载工作" class="headerlink" title="A.负载工作"></a>A.负载工作</h2><p>为了评估我们提出的方案，我们运行了11个持久性应用程序。如表三所示，其中六个基准是内部开发的，所有这些都是为了强调内存的使用，并在以前的工作中使用过[37]。每个应用程序的功能描述如下</p>
<ol>
<li>ARSWP:该基准从数据库中随机选择两个密钥并进行交换。 </li>
<li>RANDWR:选择随机钥匙，用所选钥匙的数据库条目更新一个随机值。</li>
<li>SEQWR:这与RANDWR类似，但钥匙是按顺序选择的，从数据库的第一个元素开始。 </li>
<li>AVL:数据库被映射到AVL树上，并在映射的数据库中搜索一个随机生成的密钥。如果没有找到密钥，则触发插入操作。 </li>
<li>BTREE:该基准将数据库映射为B树，与AVL类似，搜索一个随机密钥， 如果没有找到，则用假数据插入密钥。 </li>
<li>RBTREE:与AVL和BTREE基准类似，RBTREE基准将数据库映射为RB树， 并搜索一个随机密钥。</li>
</ol>
<p> <img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/d02f12cdf7f04e548613eeaf042b87fb.png"><br>我们还运行了由威斯康星大学麦迪逊分校与惠普实验室合作开发的WHISPER基准测试套件[41]中的五项基准(表三中前面有W：)。TPCC基准测量的是基于复杂数据库和在其上执行的各种数据库事务的在线交易处理系统(OLTP)的性能。雅虎云服务基准( YCSB)是一个用于评估数据库管理系统的编程套件。W:TPCC和W:YCSB基准是Whisper基准套件的变种，它是以N-Store[12]为模型的，N-Store是一个持久性内存的远程数据库管理系统。W:CTREE和W:HASHMAP基准是使用NVML[56]库开发的，该库对持久性存储器区域执行插入、删除和获取操作。W:ECHO是一个用于持久性内存区域的可扩展键值存储。对W: CTREE和W:HASHMAP基准的地图获取功能进行了评估。</p>
<p>所有这些基准的密钥大小为512比特，数据库大小为1GB。在评估这些基准之前，首先用随机密钥填充数据库。这些基准的每千条指令的失误率( MPKI)见表III。每个基准对500M指令进行了评估。</p>
<h2 id="B-DRAM-Mirror-Configuration镜像配置"><a href="#B-DRAM-Mirror-Configuration镜像配置" class="headerlink" title="B. DRAM Mirror Configuration镜像配置"></a>B. DRAM Mirror Configuration镜像配置</h2><p>为了镜像虚拟机的数据，我们使用了32MB的DRAM。然而，正如第五章E节中所讨论的那样， 我们把镜像区域的大小从2MB到1GB不等(整 个DRAM被用作镜像区域)。最小化是以页为单位进行的。在MQ机制中，只有当页面达到MQ级别4时才会被镜像，也就是说，当一个页面被读取16次时。纪元的时间间隔被设置为10000次读取操作。尽管我们用上述配置评估了StealthPersist方法，但我们通过改变DRAM镜像、大小和阈值水平来进行敏感性分析。由内存控制器维护的镜像表缓存的大小为128组，每组有 6个映射。镜像表缓存的查找延迟为1ns。</p>
<h1 id="五、评估"><a href="#五、评估" class="headerlink" title="五、评估"></a>五、评估</h1><p>在本节中， 我们讨论了Stealth-Persist与直接使用NVM进行持久化的系统的对比结果。我们进一步展示了通过改变影响性能的不同参数而进行的敏感性分析。</p>
<h2 id="A-Stealth-Persist对性能的影响"><a href="#A-Stealth-Persist对性能的影响" class="headerlink" title="A.Stealth-Persist对性能的影响"></a>A.Stealth-Persist对性能的影响</h2><p>图7显示了使用Stealth-Persist方法的性能改进。基准方案是OptaneDC AD模式方案，其中所有的持久性内存请求都只存储到持久性内存(NVM)。这是实现此类系统的持久性应用的数据持久性的典型方式。平均而言，使用Stealth-PersistMQ和FTP方法，性能提高了30.9%和42.02%。应用程序的性能改善是镜像区域命中率的一个函数，这一点在第V-B节中讨论。Stealth-Persist FTP的改进高于Stealth-Persist MQ方法，因为每一个被读取的页面都在DRAM中被镜像这导致了大量的页面从NVM复制到DRAM中。平均来说，我们观察到隐身传输FTP比隐身传输MQ方法多镜像了542.96倍的页面，这大大增加了内存总线的流量和能源使用。对于像SEQWR和W:ECHO这样的顺序内存访问基准，Stealth-Persist FTP的改进是巨大的–2.34倍和2.5倍。分别为2.2倍。由于这些基准是按顺序访问内存的，所以这些基准的空间定位性很高。因此，当一个页面被读取时它立即被镜像到Stealth-persist FTP中，并被访问为连续的内存访问。另一方面，Stealth-Persist MQ方法，首先，页面应该达到一个阈值才能被镜像。对于AVL和RBTREE工作负载来说，隐身主义MQ方法优于隐身主义FTP，因为隐身主，义FTP非常频繁地替换镜像区域的页面，这导致了从镜像区域驱逐热页面。另一方面，Stealth-persist MQ方法倾向于将热页保留在镜像区域。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/fd4aaaa8276a419c8b119a5ad7190607.png"><br>对于ARSWP工作负载，Stealth-Persist方案的性能与Optane DC应用二维模式相比几乎没有变化，从图3来看，与使用DRAM作为主内存的系统相比，它受到了很大的影响它的速度要慢4.39倍。然而，ARSWP应用程序的内存访问非常稀疏，因此页面的重用距离很高，这导致在Stealth-persist FTP方法中，在这些页面被重用之前就被驱逐了。此外，ARSWP应用程序的页面没有达到Stealth-Persist MQ方法的镜像限制。因此，性能下降了3%，在由于检查镜像区域而只有0.02%的命中率，MQ方法。另一方面，由于有3%的命中率，Stealth-persist FTP的性能在ARSWP基准中提高了1.6%。然而，如第V-E1节所示，当镜像区域的大小增加时，ARSWP的性能得到改善。</p>
<h2 id="B-DRAM镜像命中率"><a href="#B-DRAM镜像命中率" class="headerlink" title="B.DRAM镜像命中率"></a>B.DRAM镜像命中率</h2><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/55e20b926dcb4b9ababf12230c83b888.png"><br>图8显示了由DRAM镜像区域提供服务的读取百分比。我们注意到，有顺序内存访问的应用显示出最好的性能改进FTP在这些应用中显示出非常高的命中率。另一方面，在Stealth-Persist MQ方法中，具有随机跨度访问的应用和具有热页的应用显示出最高的命中率。如图8所示，在Stealth- Persist FTP方法中，镜像页平均占整个内存读取的57.81%。对于Stealth-Persist MQ，与Stealth-Persist FTP相比，它以合理的页面镜像数量服务于平均24.78%的整体读取。如图8所示，具有最高命中率的内存约束应用程序显示出最高的性能改进。在Stealth-Perist FTP中，WHISPER基准的镜像命中率，如CTREE和HASHMAP很高，但性能的提高没有SEQWR和ECHO基准那么多。这是因为CTREE和HASHMAP应用不像EPOCH和SEQWR那样内存密集，这与CTREE和HASHMAP的MPKI有关，如表三所示CTREE的MPKI为1.75，HASHMAP的MPKI为0.84。</p>
<h2 id="C-Stealth-Persist对NVM读取的影响"><a href="#C-Stealth-Persist对NVM读取的影响" class="headerlink" title="C.Stealth-Persist对NVM读取的影响"></a>C.Stealth-Persist对NVM读取的影响</h2><p>在这一节中，我们展示了使用Stealth-Persist方法减少发送到NVM的读取次数。当镜像区域的命中率很高， 大部分的读取都由镜像区域提供<br>这就减少了发送到NVM的读取数量。图9显示，与Optane DC AD模式( 100%)相比,使用Stealth-Persist FTP和MQ方法，NVM的读取次数平均减少了 88.28%和73.28%。对于SEQWR和W:ECHO基准来说，使用Stealth-Perist FTP显示出最高的性能改进，NVM读数分别明显减少了98.42%和98.02%。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/0491934cb8024507bcb52dedff4c7835.png"></p>
<p>如图10所示，Stealth-Persist万案对写入NVM的次数没有任何影响。然而,Stealth-Persist也会将镜像页的写入发送到DRAM中。因此，Stealth-Persist不影响NVM的写入持久性，也不增加能耗，这可能是由于增加NVM的写入量造成的。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/cf110ec94f8d4ebeace793e8ad7a01e1.png"></p>
<h2 id="E-敏感度分析"><a href="#E-敏感度分析" class="headerlink" title="E.敏感度分析"></a>E.敏感度分析</h2><p>尽管Stealth-Persist FTP和MQ与基线( OptaneDC AD模式)相比，平均提高了42.02%和30.9%的性能,但仍有改进的余地，因为镜像区域的命中率平均为57.81%和24.78%。错过的原因有很多，但主要是受Stealth-Persist设计中的镜像区域大小和镜像阈值的影响然而增加镜像区域的大小将增加硬件的复杂性( 镜像表的大小),而减少镜像阈值可能会导致提前替换所需的页面，这可能会导致会降低整体性能。为了充分分析镜像区域大小和镜像阈值的影响，我们在本节中改变了镜像区域大小和镜像阈值。此外，我们还展示了快速和慢速NVM.上的性能改进。所<br>有工作负载的平均值显示在敏感性结果中。</p>
<p>1)镜像区域对性能的影响。在DRAM中可以被镜像的持久性页面的数量取决于为镜像保留的DRAM内存的百分比。为了避免大量的内存开销， Stealth-Persist只保留了32MB的DRAM，也就是模拟系统中DRAM的3.125%，用于镜像持久性内存页。然而，正如前面所讨论的， 在使用Stealth-Persist时，可以镜像的页面越多，系统性能的上限就越大。因此，我们将镜像区域的大小从2MB改为1GB，以评估Stealth-Persist的性能改进。请注意，当镜像区域的大小为1GB时整个DRAM都被保留用于缓存镜像页面。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/43bef6e28284442c84f9a398b2558af4.png"></p>
<p>图11显示，增加镜像区域的大小可以提高FTP和MQ的性能。当镜像区域大小从2MB增加到1GB时，Stealth-Perist FTP的性能改善从1.28倍增加到1.83倍，Stealth-Perist MQ从1.14倍增加到1.38倍。由于MQ是一种基于确认的方法，只有当NVM页面被访问的次数超过阈值(4)时才会被镜像，所以在使用Stealth-Persist MQ的64MB镜像区域大小后，改进已经饱和。因此，即使镜像区域的大小增加了， 要镜像的页面数量也受到阈值的限制，因此性能的提高是饱和的。当镜像区域大小为64MB时，使用Stealth-Perist FTP的性能提升为1.48倍，使用Stealth-Perist MQ为1.35倍。另外，正如所断言的那样，ARSWP基准在32MB的镜像大小下没有显示出性能的改善， 在镜像区域大小为64MB、128MB、 256MB、512MB和1GB时，Stealth-Persist FTP分别实现了1.06倍、 1.22倍、 1.75倍、 2.65倍和3.22倍的改善。然而，使用Stealth-Persist MQ，我们观察到没有任何改善，因为ARSWP应用程序的页面没有达到镜像阈值。</p>
<p>2)镜像阈值水平对性能的影响。在图12中，我们显示了改变镜像的结果。阈值队列水平。当阈值水平降低时，使用Stealth-Perist<br>MQ方法的性能改善会增加。我们观察到，当阈值水平设置为1时，性能提高了1.46倍;当阈值水平为4时，性能提高了1.3倍。当阈值水平降低时，Stealth-Persist表现得很积极，因为有更多的页面被识别为镜像的候选。也就是说，当阈值水平为1时，如果应用程序至少读了2次页面，该页面就被确定为镜像候选。但是，当阈值水平为4时，只有当一个页面被读取至少16次时才会被镜像。因此，通过降低阈值水平实现的性能改善是以增加镜像的页面数量为代价的。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/6e837cd8fd5146e4bf6af4d90366c21e.png"></p>
<p>另一方面，由于两个原因，增加阈值水平会损害性能的提高。1) 一个页面在达到阈值水平后被镜像，随着队列水平的增加，应用程序必须更频繁地访问该页面才能被确定为镜像候选。一般来说，这些页面的比例很小，而且它们经常被缓存在处理器中。2)在达到阈值水平后，页面的热度会消失。例如，如果阈值水平被设置为6，一个页面必须被访问至少64次才能被镜像。然而，在访问该页64次后，应用程序可能不再需要访问该页，从而否定了镜像的影响。</p>
<ol start="3">
<li>NVM读/写延迟对性能的影响。尽管NVM的读取延迟与DRAM的读取延迟相当， 但它仍然比DRAM的读取延迟慢。与DRAM相比，NVM的写延时明显受到影响。在将页面从NVM镜像到DRAM的过程中，NVM的读/写延迟至失重要。因此，我们研究了Stealth-Persist对慢速和快速NVM的读/写延迟的影响。我们改变了NVM的读和写延迟，如图13所示。图13将NVM分为4种类型–中等:读写延迟为150ns和500ns，慢:读写延迟为300ns和700ns，非常慢:读写延迟为500ns和900ns，超慢:读写延迟为750和1000ns。随着NVM的读/写延迟的增加，使用Stealth-Persist的性能改善也会增加。对于超慢的NVM，Stealth-Persist在使用FTP和MQ时，性能分别提高了1 .87倍和1.54倍。<br><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/32440afd47dd4fa4a7d9a7960e24f83c.png"></li>
</ol>
<h1 id="六、相关工作"><a href="#六、相关工作" class="headerlink" title="六、相关工作"></a>六、相关工作</h1><p>混合内存。最近，很多工作都在探索如何提高混合存储器系统的性能。例如，Ramos等 人[48]提出了一个在混合内存系统中放置<br>页面的方案。该方案使用多队列对页面进行排序，并且只将性能关键的页面迁移到DRAM中。然而，该方案并没有确保数据的持久性，只是专注于将性能矣键的页面放在DRAM中。HetroOs[27]的作者 提出了一个应用程序透明的万案，利用操作系统提供的应用程序的内存使用信息来决定在异构内存系统中放置数据。然而，HetroOs的动机纯粹是为了系统性能，并没有提供持久性的保证。因此，有持久性要求的应用仍将不得不承受高的NVM延迟。Nimble[58]的作者提出了一个方案，重用操作系统的页面跟踪结构，在存储器之间进行页面分层。此外，Nimble提供了一些优化，如透明的巨大页面迁移和多线程页面迁移，与本地Linux系统相比，这导致了40%的性能提升。然而，Nimble改善了内存之间的页面迁移，但并没有确保数据的持久性。Agarwal等 人[10]为混合内存系统中的GPU提出了一个页面放置方案。然而，所提出的方案是根据应用带宽要求在存储器之间迁移页面，没有考虑数据的持久性。Yoon等人[60]设计了一个策略，使DRAM能够在NVM内存中<br>缓存具有高频率的行缓冲区失误的页面。CAMEO[20]、PoM[54]、Mempod[45]和BATMAN[21]讨论 了可能的放松措施，以最大化整体内存带宽。所提出的技术依赖于编译器支持或Linux内核来检测感兴趣的页面。Lim等人[36]和Kommareddy等人[30]探讨了在分解内存系统中把远程页面迁移到本地内存的问题。</p>
<p>NVM数据的持久性。确保NVM驻留数据的持久性、性能和崩溃的一-致性最近一直是 人们矣注的焦点。例如，Janus[37]通过将后端内存操作分解为较小的超操作， 然后将超操作重叠起来，改善了持久性应用的写入延迟。除了前面提到的NVM库，英特尔的PMDK[9]、REWIND[18]、 NV-Heaps[22]和LSNVMM[25]为程序员提供了基于软件的高级接口，以确保数据的持久性并提供崩溃一致性支持 。基于硬件的</p>
<h1 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h1><p>要提高Hyblid内存系统中的持久性应用的性能，需要在DRAM中缓存NVM常驻数据。然而，將持久性应用的数据缓存在DRAM中会使这些缓存页的持久性失效。确保DRAM缓存页的持久性可以通过DRAM的电源备份来实现。然而，使用电池给DRAM供电是昂贵的，不可靠的，与传统的系统不兼容，而且不环保。因此，我们提出了Stealth-Pert，一种新型的内存控制器，允许在DRAM中 缓存NVM的识别页面，同时保证页面的持久性。通过从DRAM为NVM请求提供服务，Stealth-Perist利用了银行级别的并行性，减少了内存的消耗并带来了额外的性能提升。Steallh-Persit使 用StealthPersiFfP，在混合内存系统中， 每项应用的系统性能平均提高42.02%。然而，Stealth-PersiFfP需要将大量的页面从虚拟机复制到DRAM中。通过Steallb-PersitMQ方法，我们在合理的页面min-or下，性能提高了30.09%。Tealthisl通过商场硬件管理表、U1e内存控制器中的商场缓存以及利用WPQ来实现这一改进。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">易百分</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://ytirus.github.io/2023/05/01/Stealth-Persist-Architectural-Support-for-Persistent-Applications-in-Hybrid-Memory-Systems/">http://ytirus.github.io/2023/05/01/Stealth-Persist-Architectural-Support-for-Persistent-Applications-in-Hybrid-Memory-Systems/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">易百分</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Hybrid-Memory-Systems/">
                                    <span class="chip bg-color">Hybrid Memory Systems</span>
                                </a>
                            
                                <a href="/tags/A/">
                                    <span class="chip bg-color">A</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/05/02/Supporting-Superpages-and-Lightweight-Page-Migration-in-Hybrid-Memory-Systems/">
                    <div class="card-image">
                        
                        <img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/76369fa4b49c432fa9e498567df6adf4.png" class="responsive-img" alt="Supporting Superpages and Lightweight Page Migration in Hybrid Memory Systems">
                        
                        <span class="card-title">Supporting Superpages and Lightweight Page Migration in Hybrid Memory Systems</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            提出了一种称为Rainbow的新的内存管理机制来弥合超级页面和轻量级页面迁移之间的根本冲突
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-05-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Paper/" class="post-category">
                                    Paper
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Hybrid-Memory-Systems/">
                        <span class="chip bg-color">Hybrid Memory Systems</span>
                    </a>
                    
                    <a href="/tags/A/">
                        <span class="chip bg-color">A</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/01/Object-Level-Memory-Allocation-and-Migration-in-Hybrid-Memory-Systems/">
                    <div class="card-image">
                        
                        <img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/1560f56c3c8c4c2bac8a3b2f22c9ece4.png" class="responsive-img" alt="Object-Level Memory Allocation and Migration in Hybrid Memory Systems">
                        
                        <span class="card-title">Object-Level Memory Allocation and Migration in Hybrid Memory Systems</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            提出混合内存系统编程接口, 对象粒度迁移, 减少迁移开销,减少能源。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Paper/" class="post-category">
                                    Paper
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Hybrid-Memory-Systems/">
                        <span class="chip bg-color">Hybrid Memory Systems</span>
                    </a>
                    
                    <a href="/tags/A/">
                        <span class="chip bg-color">A</span>
                    </a>
                    
                    <a href="/tags/%E7%BB%86%E7%B2%92%E5%BA%A6/">
                        <span class="chip bg-color">细粒度</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">易百分</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">164k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Yitrus" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:citrusyi@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我citrusyi@163.com" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
