<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/01/hello-world/"/>
      <url>/2023/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="1-Create-a-new-post"><a href="#1-Create-a-new-post" class="headerlink" title="1.Create a new post"></a>1.Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令会在/source/_posts下创建新文章，之后需要使用MarkDown语法编写该文章。  </p><p><code>---</code>包括起来的内容称之为<code>Front-matter</code>有很多配置选项可以添加。<br>更多的简单语法可以参考<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a><br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="2-清除旧数据"><a href="#2-清除旧数据" class="headerlink" title="2.清除旧数据"></a>2.清除旧数据</h3><p>文章写好之后，首先清除掉旧的数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会清除掉之前生成的网页，即站点根目录下的public文件夹</p><h3 id="3-Generate-static-files"><a href="#3-Generate-static-files" class="headerlink" title="3.Generate static files"></a>3.Generate static files</h3><p>然后使用如下命令生成新的页面：More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate 或者简写 hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会将source文件夹下所有的md文件进行渲染，生成HTML页面，存放在public文件夹下</p><h3 id="4-Run-server"><a href="#4-Run-server" class="headerlink" title="4.Run server"></a>4.Run server</h3><p>在本地开启服务器，预览一下文章是否满意</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server  <span class="token string">'hexo s'</span> <span class="token keyword">for</span> short<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="5-Deploy-to-remote-sites"><a href="#5-Deploy-to-remote-sites" class="headerlink" title="5.Deploy to remote sites"></a>5.Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy <span class="token string">'hexo d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Blog-Template"><a href="#Blog-Template" class="headerlink" title="Blog Template"></a>Blog Template</h2><p>更高阶更详尽的Hexo Markdown教程参考<a href="https://blog.17lai.site/posts/cf0f47fd/#%E5%B8%B8%E7%94%A8%E6%A0%87%E8%AE%B0">夜法之书的博客</a><br>一些可以用到的LeTax数学公式编辑方式<a href="http://t.csdn.cn/VivVj">超详细 LaTex数学公式</a> || <a href="http://t.csdn.cn/iPVFt">LaTeX数学公式-详细教程</a></p><p>图床就是用csdn了 <span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this is a test for my first blog</title>
      <link href="/2023/04/30/this-is-a-test-for-my-first-blog/"/>
      <url>/2023/04/30/this-is-a-test-for-my-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="詹青云2018年华语辩论世界杯决赛结辩"><a href="#詹青云2018年华语辩论世界杯决赛结辩" class="headerlink" title="詹青云2018年华语辩论世界杯决赛结辩"></a>詹青云2018年华语辩论世界杯决赛结辩</h2><p>大家好，我们今天和对方有三个根本的分歧。一是成功路径不同。我方承认，聚焦没有问题。如果一个年轻人在年轻的时代完全知道一生要什么，一生走下去从不后悔。没问题，挺幸福的。可是现实是，这个决定对于大多数人来说不应该在青年时代做。这个时候你的大脑没有发育完全、你的人生还在不停地变动、你的智识还有限，而这个世界在飞快的变化。很有可能你想要聚焦的东西有一天是你不适应、不喜欢或者被时代淘汰的东西。</p><p>这时候您方跳到了第二点告诉我说没关系，我只要坚定自己的内心我就没有问题了。这就是我们双方第二点分歧：幸福观的不同。您方的幸福观是一种妥协的幸福观，而我放的幸福观是进取的幸福观。您方的意思是不管我人生发挥得怎样，社会如何对待我，不用在乎！我妥协、我看开、我豁达，就可以幸福。对方辩友，那些历史上真正收获了豁达心态的人，杨慎“是非成败转头空”，王维“行到水穷处，坐看云起时”的时候，他们是在什么时候收获这种豁达，是在遍历人生的沧桑，经历了繁华，经过了奋斗，见识了人世中更深刻的道理，他可以领悟到繁华。就算我退一步，俗一点讲，我多读一点书，多看一点世界，对这个世界的理解和思考方式丰富一点，这种做加法的方法您才能收获真的豁达。</p><p>最后我们双方最根本的分歧是对这个时代理解不同。您告诉我说这个世界纷繁复杂，已经把太多选择推到年轻人的面前，所以我选择加就是在随大流。不是。我们仔细想一想，这个时代给我们多的选择不过是您方说的商品、营销课、成功学。可是人生加减法上，那些人生重大关头的选择是什么，这个社会真的在逼我们做加法吗？不是。我到了这个年纪就应该结婚生子，成家立业。在人生重大关头的选择上，这个社会是要求青年人割舍那些不切实际的幻想，割去那些错误的观念，回归一套社会范式，一套人生范式，是要求你做减法的。</p><p>这个时候真正追随自己内心是应该不顾这套范式的束缚，冲破束缚去追寻自己心中所爱，活出一个真正多元的世界。更重要的是，我们今天不是在替一个年轻人的幸福说话，是一代青年人。青年人拓宽人生边界的可能是在拓宽这个社会价值判断的可能。</p><p>既然这个世界号称它是多元而包容的，我们就应该去试，去让他实现这个诺言。</p><p>既然这个社会多元而包容，既然这个世界告诉我们“人不轻狂枉少年”，就没有人应该天然地觉得“轻狂”是一个贬义词。对方辩友一直在劝我们：人生选到自己最幸福的东西才是快乐的。对方辩友，各位，我们都是年轻人。在我们人生的这个阶段，有什么东西是唯一珍贵的？什么叫“欲买桂花同载酒，终不似，少年游”，什么叫“旧游无处不堪寻。无寻处，惟有少年心”。那个唯一带不走的东西，不就是青春本身吗？这一份机会你不珍惜，这一份可能你不珍惜，您跟我谈的是什么？是那一份安顿了的幸福，是那一份成熟了的幸福。可是这不是年轻人的幸福。因为年轻人不是在替你一个人谋幸福，不是你一个人看开了就可以。他是要为这个世界拓宽边界，是让所有的人都有机会把道路越走越宽，是</p><p>趁着年轻，我偏要勉强。</p><p>谢谢大家。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Perspective </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Time Complexity Calculation</title>
      <link href="/2021/06/06/Time-Complexity-Calculation/"/>
      <url>/2021/06/06/Time-Complexity-Calculation/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见阶大小比较"><a href="#一、常见阶大小比较" class="headerlink" title="一、常见阶大小比较"></a>一、常见阶大小比较</h2><p>从大到小：  </p><ul><li>超指数阶：$n^n$，$n!$</li><li>指数阶：$9^{n/2}$,  $2^n$</li><li>多项式阶：$n^3$,   $n*log(n)$, $n^{1/2}$</li><li>对数阶：$log^2(n)$, $log(n)$, $log(log(n))$</li><li>常数阶：100, 1<br>下题需要保留阶最高的部分：<img src="https://img-blog.csdnimg.cn/20210605220748744.jpg"></li></ul><h2 id="二、算法复杂性估计函数"><a href="#二、算法复杂性估计函数" class="headerlink" title="二、算法复杂性估计函数"></a>二、算法复杂性估计函数</h2>$$\lim_{n \to \infty} \frac{f(n)}{g(n)}  =\begin{cases}(大于0的常数或)0       &amp;&amp;&amp; f(n)=O(g(n))上界&amp;-----f(n)\le cg(n)\\(大于0的常数或)无穷    &amp;&amp;&amp; f(n)= \Omega(g(n))下界&amp;-----f(n)\ge cg(n)\\大于0的常数            &amp;&amp;&amp; f(n)= \Theta(g(n))确切界&amp;-----f(n)=cg(n)\\0      &amp;&amp;&amp;f(n)=o(g(n))上界&amp;-----f(n)&lt; cg(n)\end{cases}$$<p>可以发现都是针对f(n)在讨论，很容易得出下题答案：<img src="https://img-blog.csdnimg.cn/20210605220628312.jpg"></p><h2 id="三、几个常用替换的式子"><a href="#三、几个常用替换的式子" class="headerlink" title="三、几个常用替换的式子"></a>三、几个常用替换的式子</h2><h3 id="1-Stirling公式："><a href="#1-Stirling公式：" class="headerlink" title="1.Stirling公式："></a>1.Stirling公式：</h3>$$n! \approx {(2 \pi n)}^{1/2}{(n/e)}^n$$<p><img src="https://img-blog.csdnimg.cn/20210605222019202.jpg"></p><h3 id="2-阶乘和二项式系数"><a href="#2-阶乘和二项式系数" class="headerlink" title="2.阶乘和二项式系数"></a>2.阶乘和二项式系数</h3>$$C_n^k = C_n^{n-k} \\ C_n^n = C_n^0 = 1 \\C_n^k = C_{n-1}^k +C_{n-1}^{k-1} $$<p>帕斯卡三角形可以辅助记二项式系数：<img src="https://img-blog.csdnimg.cn/2021060522532381.jpg"></p>$$\sum_{j=0}^{n}{C_{n}^j}x^j= {(1+x)}^n $$<h3 id="3-和式"><a href="#3-和式" class="headerlink" title="3.和式"></a>3.和式</h3>$$\sum_{j=1}^{n}{a_{n-j}} = \sum_{j=0}^{n-1}{a_j} \\\sum_{j=0}^n{j \over 2^j} = \sum_{j=1}^n{j \over 2^j} = 2-{{(n+2)} \over {n^2}} = \Theta(1) \\\sum_{j=0}^njc^j = \sum_{j=1}^njc^j = \Theta(nc^n)$$<h3 id="4-定积分与和式转换"><a href="#4-定积分与和式转换" class="headerlink" title="4.定积分与和式转换"></a>4.定积分与和式转换</h3>$$\int_m^{n+1} f(x) dx  \le \sum_{j=m}^nf(j) \le \int_{m-1}^nf(x)dx 递减函数 \\\int_{m-1}^{n} f(x) dx  \le \sum_{j=m}^nf(j) \le \int_{m}^{n+1}f(x)dx  递增函数$$<p>可以采用画图的方法辅助记忆它的上下界：<br>以一个递增的函数为例，我们要求1（m）~6（n）他的面积，每一个小矩形$1*f(j)$如果我们积分每个点左边的矩形，那么总面积就是偏小的，积分右边矩形就会稍微偏大，这就找到了上下界，当函数平行于X轴时就会有等号。递减也是一个道理。<img src="https://img-blog.csdnimg.cn/20210606094351964.jpg"><br>但是，如果是logn等函数会遇到定义域不存在的情况。我们应该从和式中把（在积分中）没有定义的点先拿出来，再去积分。<img src="https://img-blog.csdnimg.cn/2021060610042349.jpg"></p><p>用代数方法证明就是放大缩小去求，用积分方法证明就是用上面那个公式。可以看到积分方法求时等式左边按公式应该为$\int_0^n jlogj !\ dj$定义域<br>不存在，所以对于右边：</p>$$\sum_{j=1}^njlogj=\sum_{j=2}^njlogj+1log1=\int_{2-1}^njlogj \!\ dj+1log1$$<h2 id="四、计算次数"><a href="#四、计算次数" class="headerlink" title="四、计算次数"></a>四、计算次数</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">算法:COUNT输入:n=2k,k为正整数。输出: count的值 。count=0while n&gt;=1for j=1 to ncount=count+1n=n/2return countend COUNT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>while要执行k+1次，$k=log_2n$.for循环在每次while的基础上执行n次所以(k+1)n即$nlog_2n$次计算</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">算法: MERGE输入:数组A[1..m]和它的三个索引p, q, r, 1&lt;=p&lt;=q&lt;r&lt;=m。两个子数组A[p..q]和A[q+1..r]各自按升序排列。输出:合并两个子数组A[p..q]和A[q+1..r]的升序数组A[p..r]for(s=p, t=q+1, k=p; S&lt;=q and t&lt;=r; k++)if A[s]&lt;=A[t] //两个指针从两个头开始排序B[k]=A[s]; //B[p..r]是个辅助数组S=S+1;elseB[k]=A[t];t=t+1;if s=q+1 B[k..r]=A[q+1..r] elseB[k..r]=A[s..q]A[p..r]=B[p..r]end MERGE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两段相邻数组分别有序，两个指针将两段变为有序的。2(r-p+1)先遍历一次排序，在从排好序的辅助数组移回来。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">void insertion_ sort(Type *a, int n){// 代价 次数// ti: for的第i次while的循环次数for (int i=1; i&lt;n; i++){// c1   n(比较语句)key=a[i];// c2   n-1int j=i-1;// c3   n-1while( j&gt;=0 &amp;&amp; a[j]&gt;key ){  // c4   sum tia[j+1] = a[j];// c5   sum of (ti-1)j--;// c6sum of (ti-1)}a[j+1]=key; // c7   n-1}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入排序的思想是左手为空，右手的牌按序插入。这里t是个不确定的数，但是还是可以得出计算次数为：</p><p>$$c_1n+c_2(n-1)+c_3(n-1)+c_4\sum_{i=1}^{n-1}{t_i}+c_5\sum_{i=1}^{n-1}{(t_i-1)}+c_6\sum_{i=1}^{n-1}{(t_i-1)}+c_7(n-1)$$</p><p>最好情况就是已经排好序了，c5与c6都是0，每次for的while都只跑一次。<br>$$c_1n+c_2(n-1)+c_3(n-1)+c_4(n-1)+c_7(n-1) = O(n)$$<br>最坏情况就是倒序排的，n张牌每次都比上一次多查找一个。</p><p>$$\sum_{i=1}^{n-1}{(t_i-1)} = n(n-1)/2$$</p><p>复杂度$O(n^2)$</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">1. COUNT42.count &lt;-- 03.for i ←- 1 to Llogn」4.for j ←- i to i+55.for k ←- 1 to i^26.         count ←- count +17.end for8.  end for9.end for(a)第6步执行了多少次?(b)要表示算法的时间复杂性，用0和O哪个符号更合适?为什么?(c)算法的时间复杂性是什么?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>a）思路是把每次for循环乘起来。<br>$$\sum_{i=1}^{\lfloor logn \rfloor}\sum_{j=i}^{i+5}\sum_{k=1}^{i^2}{1}$$内层指的是从1到$i^2$个1相加$=\sum_{i=1}^{\lfloor logn \rfloor}\sum_{j=i}^{i+5}{i^2} = 6\sum_{i=1}^{\lfloor logn \rfloor}{i^2}$<br>利用平方和求和公式$n(n+1)(2n+1)/6$进一步化简$=\lfloor logn \rfloor(\lfloor logn \rfloor +1)(2\lfloor logn \rfloor+1)$<br>b） O 因为对于算出的确切的计算次数，这个用于表示算法时间复杂性的函数是它上界。<br>c）$O(log^3n)$</p><h2 id="五、解递归方程式"><a href="#五、解递归方程式" class="headerlink" title="五、解递归方程式"></a>五、解递归方程式</h2><h3 id="1-线性齐次递推式（二阶）"><a href="#1-线性齐次递推式（二阶）" class="headerlink" title="1.线性齐次递推式（二阶）"></a>1.线性齐次递推式（二阶）</h3><p>对于递推式:$$f(n)=a_1f(n-1)+a_2f(n-2)+…+a_kf(n-k)$$我们想要得到$f(n)$的确切解，它的解往往是$x^n$于是我们可以把这个递推式的等价于:$$x_n=a_1x^{n-1}+a_2x^{n-2}+…+a_kx^{n-k}$$将两边同时除以$x^{n-k}$并且移项可以得到与n无关还能解出x的式子$$x^k-a_1x^{k-1}-a_2x^{k-2}-…-a_k = 0$$这个就是常说的特征方程。</p><table><thead><tr><th align="center">步骤</th><th align="center">例1</th><th align="center">例2</th></tr></thead><tbody><tr><td align="center">序列</td><td align="center">1,4,16,64,256</td><td align="center">1,1,2,3,5,8(斐波拉契)</td></tr><tr><td align="center">递推关系</td><td align="center">f(n)=3f(n-1)+4f(n-2)</td><td align="center">f(n)=f(n-1)+f(n-2)</td></tr><tr><td align="center">特征方程</td><td align="center">$x^2-3x-4=0$</td><td align="center">$x^2-x-1=0$</td></tr><tr><td align="center">特征根</td><td align="center">$x_1=-1,x_2=4$</td><td align="center">$x_1= { {1+\sqrt5} \over 2},x_2={ {1-\sqrt5} \over 2}$</td></tr><tr><td align="center">通解</td><td align="center">$f(n) = c_1{(-1)}^n+c_24^n$</td><td align="center">$f(n)=c_1\left( { {1+\sqrt5} \over 2} \right)^n+c_2\left( { {1-\sqrt5} \over 2} \right)^n$</td></tr><tr><td align="center">带入序列中的点</td><td align="center">$c_1=0,c_2=1$</td><td align="center">$c_1={1\over {\sqrt5}},c_2=-{1\over {\sqrt5}}$</td></tr><tr><td align="center">最终解</td><td align="center">$f(n)=4^n$</td><td align="center">由于n无穷大$c_2\left( { {1-\sqrt5} \over 2} \right)^n$趋于0,$f(n)={1\over {\sqrt5}}\left( { {1+\sqrt5} \over 2} \right)^n$</td></tr></tbody></table><p>还有种特殊情况：$x_1=x_2=x$时$f(n)=c_1nx^n+c_2x^n$</p><h3 id="2-非齐次递推式"><a href="#2-非齐次递推式" class="headerlink" title="2.非齐次递推式"></a>2.非齐次递推式</h3><h4 id="2-1-f-n-f-n-1-g-n"><a href="#2-1-f-n-f-n-1-g-n" class="headerlink" title="2.1  f(n)=f(n-1)+g(n)"></a>2.1  f(n)=f(n-1)+g(n)</h4><p>对于这一类g(n)是一个已知的函数，推导可得：<br>$$f(n) = f(n-1)+g(n) = \big(f(n-2)+g(n-1)\big)+g(n) = f(0)+ \sum_{j=1}^ng(j)$$<br><img src="https://img-blog.csdnimg.cn/20210606120205290.jpg"><br>这道题麻烦点在于怎么把前面的系数3搞没了。由1我们知道，这种递推式是$f(n)=x^n$变形令$f(n)=3^nq(n), f(0)=q(0)=3$于是乎原式变为：</p>$$3^nq(n)=3*3^{n-1}q(n-1)+2^n \\ q(n)=q(n-1)+{(2/3)}^n\\ q(n)=q(0)+\sum_{j=1}^n{{(2/3)}^n}\\ f(n)=3^n*\big(3+{(2/3)(1-{(2/3)}^n) \over {1-(2/3)}}\big) \\ f(n)=5*3^n+2^{n+1}$$<h4 id="2-2-f-n-f-n-1-g-n"><a href="#2-2-f-n-f-n-1-g-n" class="headerlink" title="2.2  f(n)=f(n-1)*g(n)"></a>2.2  f(n)=f(n-1)*g(n)</h4><p>对于这一类g(n)也是一个已知的函数，推导可得：<br>$$f(n) = f(n-1)*g(n) = \big(f(n-2)*g(n-1)\big)+g(n) = f(0)\prod_{i=1}^ng(i)$$</p><h4 id="2-3-f-n-f-n-1-g-n-h-n"><a href="#2-3-f-n-f-n-1-g-n-h-n" class="headerlink" title="2.3  f(n)=f(n-1)*g(n)+h(n)"></a>2.3  f(n)=f(n-1)*g(n)+h(n)</h4><p>可以直接推，也可以带点技巧推。结果：$$=\prod_{i=1}^ng(i)\big( f(0)+\sum_{j=1}^n{h(j) \over{\prod_{i=1}^ng(i)} } \big)$$</p><h4 id="2-4-f-n-af-n-c-g-n"><a href="#2-4-f-n-af-n-c-g-n" class="headerlink" title="2.4 f(n)=af(n/c)+g(n)"></a>2.4 f(n)=af(n/c)+g(n)</h4>$$f(n)=\begin{cases} d&amp; \text{n=1}\\af({n\over c})+bn^x&amp; \text{n &gt;= 2} \end{cases}$$<p>其中d非负常量，g(n)非负函数，a，c正数。设$n=c^k$</p>$$f(n)=\begin{cases} bn^x*log_cn^x+dn^x&amp;{a=c^x}\\ \big(d+{{bc^x}\over{a-c^x}}\big)n^{log_ca}-\big({{bc^x}\over{a-c^x}}\big)n^x&amp; {a\neq c^x} \end{cases}$$<p><img src="https://img-blog.csdnimg.cn/20210606123724891.jpg"><br>这道题就没有为难菜鸡，直接把方向给了。这种做法在遇到f(n/2)的情况下叫做<strong>更换变元法</strong><br>$$f(2^k)=f(2^{k-1})+2^k=f(2^0)+\sum_{i=1}^k2^i=2^{k+1}-1 =2n-1\<br>g(2^k)=2g(2^{k-1})+1=\sum_{i=0}^k2^i=2^{k+1}-1=2n-1$$<br>也可以直接套公式:<br>对于f   $d=1,a=1,c=2,b=1$<br>对于g  $a=2,c=2,b=1,d=1$<br>这些公式太惨绝人寰了，其他还有一些和2.4一样复杂的，等遇到了再补充上去。</p><h2 id="六、p、np、np-hard、np-complete问题"><a href="#六、p、np、np-hard、np-complete问题" class="headerlink" title="六、p、np、np-hard、np-complete问题"></a>六、p、np、np-hard、np-complete问题</h2><p><a href="https://blog.csdn.net/birduncle/article/details/94646993">p、np、np-hard、np-complete问题</a>这篇文章讲的很清晰，附上一张从文章里拿的<img src="https://img-blog.csdnimg.cn/20210704092654261.png"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
